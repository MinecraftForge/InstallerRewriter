/*
 * Installer Rewriter
 * Copyright (c) 2021.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation version 2.1
 * of the License.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
package net.minecraftforge.ir;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Table;
import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import net.covers1624.quack.io.IOUtils;
import net.covers1624.quack.maven.MavenNotation;
import net.covers1624.quack.util.HashUtils;
import net.covers1624.quack.util.SneakyUtils;
import net.minecraftforge.ir.ClasspathEntry.LibraryClasspathEntry;
import net.minecraftforge.ir.ClasspathEntry.StringClasspathEntry;
import net.minecraftforge.ir.json.Install;
import net.minecraftforge.ir.json.Manifest;
import net.minecraftforge.ir.json.V1InstallProfile;
import net.minecraftforge.ir.json.Version;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.maven.artifact.versioning.ComparableVersion;

import java.io.*;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.*;
import java.util.*;
import java.util.jar.Attributes;
import java.util.stream.Collectors;

import static net.covers1624.quack.util.SneakyUtils.sneak;
import static net.minecraftforge.ir.InstallerRewriter.*;
import static net.minecraftforge.ir.Utils.makeParents;

/**
 * Created by covers1624 on 1/5/21.
 */
@SuppressWarnings ("UnstableApiUsage")
public class InstallerV1Processor implements InstallerProcessor {

    private static final Logger LOGGER = LogManager.getLogger();

    private static final HashFunction SHA1 = Hashing.sha1();

    private static final List<String> comment = Arrays.asList(
            "Please do not automate the download and installation of Forge.",
            "Our efforts are supported by ads from the download page.",
            "If you MUST automate this, please consider supporting the project through https://www.patreon.com/LexManos/"
    );

    //Overall replacements. These are checked first.
    public static final Map<MavenNotation, MavenNotation> REPLACEMENTS = ImmutableMap.<MavenNotation, MavenNotation>builder()
            .put(MavenNotation.parse("org.ow2.asm:asm:4.1-all"), MavenNotation.parse("org.ow2.asm:asm-all:4.1"))
            .build();

    //Per mc version replacements, these are run on the result of the above replacements.
    public static final Table<String, MavenNotation, MavenNotation> PER_VERSION_TABLE = HashBasedTable.create();

    static {
        PER_VERSION_TABLE.put("1.6.4", MavenNotation.parse("net.minecraft:launchwrapper:1.3"), MavenNotation.parse("net.minecraft:launchwrapper:1.7"));
    }

    private static final String SERVER_MAIN = "net.minecraftforge.legacyjavafixer.sort.ServerWrapper";
    private static final String CLIENT_MAIN = "net.minecraftforge.legacyjavafixer.sort.ClientWrapper";

    // Loaded from a jar resource, generated by InstallerTester sub-program.
    public static final Set<String> LJF_REQUIRED_VERSIONS = SneakyUtils.sneaky(() -> {
        try (InputStream is = InstallerV1Processor.class.getResourceAsStream("/ljf_versions.txt");
             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {
            return reader.lines().collect(Collectors.toSet());
        }
    });

    public static final MavenNotation LJF = MavenNotation.parse("net.minecraftforge:legacyjavafixer:2.0.0");

    @Override
    public void process(ProcessorContext ctx) throws IOException {
        boolean requiresLJF = requiresLJF(ctx.notation);
        MavenNotation baseNotation = ctx.notation.withClassifier(null).withExtension("jar");
        MavenNotation uniNotation = baseNotation.withClassifier("universal");

        Pair<Path, Path> pathPair = ctx.getFile(ctx.installer);
        try (FileSystem oldFs = IOUtils.getJarFileSystem(pathPair.getLeft(), true);
             FileSystem newFs = IOUtils.getJarFileSystem(pathPair.getRight(), true)
        ) {
            Path oldJarRoot = oldFs.getPath("/");
            Path newJarRoot = newFs.getPath("/");

            Path oldProfileFile = oldJarRoot.resolve("install_profile.json");
            if (Files.notExists(oldProfileFile)) {
                LOGGER.error("Old installer does not have 'install_profile.json'");
                return;
            }

            V1InstallProfile v1Profile;
            try (BufferedReader reader = Files.newBufferedReader(oldProfileFile)) {
                v1Profile = Utils.GSON.fromJson(reader, V1InstallProfile.class);
            }
            V1InstallProfile.Install v1Install = Objects.requireNonNull(v1Profile.install);

            String filePathStr = Objects.requireNonNull(v1Install.filePath);
            Path oldUniversalJar = oldJarRoot.resolve(filePathStr);
            if (!Files.exists(oldUniversalJar)) {
                LOGGER.error("'filePath' does not exist in old jar. {}", filePathStr);
                return;
            }

            Path newUniversalJar = newJarRoot.resolve("maven").resolve(baseNotation.toPath());
            Path repoUniversalJar = uniNotation.toPath(ctx.repoPath);
            if (!Files.exists(repoUniversalJar)) {
                LOGGER.error("Missing universal jar in configured repository, you dummy. /me looks at AterAnimAvis");
                return;
            }
            if (!Utils.contentEquals(oldUniversalJar, repoUniversalJar)) {
                LOGGER.warn("Old installer universal jar differs from repo universal jar!");
            }

            //Load libraries referenced in the 'Class-Path' manifest attribute.
            List<ClasspathEntry> classpathLibraries = Utils.parseManifestClasspath(repoUniversalJar);

            Install install = generateInstallProfile(ctx, newUniversalJar);
            Version version = generateVersionJson(requiresLJF, install, v1Profile, classpathLibraries);

            boolean classpathModified = classpathLibraries.stream().anyMatch(ClasspathEntry::isModified);

            if (classpathModified || requiresLJF) {
                LOGGER.debug("Classpath modified, updating universal jar.");
                Pair<Path, Path> uniPair = ctx.getFile(uniNotation);
                Files.copy(uniPair.getLeft(), uniPair.getRight(), StandardCopyOption.REPLACE_EXISTING);
                try (FileSystem uniFs = IOUtils.getJarFileSystem(uniPair.getRight(), true)) {
                    Path uniRoot = uniFs.getPath("/");
                    Path manifestFile = uniRoot.resolve("META-INF/MANIFEST.MF");
                    java.util.jar.Manifest manifest;
                    try (InputStream is = Files.newInputStream(manifestFile)) {
                        manifest = new java.util.jar.Manifest(is);
                    }
                    Attributes mainAttribs = manifest.getMainAttributes();
                    mainAttribs.put(new Attributes.Name("Class-Path"), classpathLibraries.stream().map(ClasspathEntry::toPath).collect(Collectors.joining(" ")));
                    if (requiresLJF) {
                        applyLJFManifest(manifest);
                    }

                    //Strip old signing info. Unsure if jar sign tool will explode or not, safe to strip regardless.
                    manifest.getEntries().clear(); // Nuke signing attributes in manifest.
                    Files.list(uniRoot.resolve("META-INF"))
                            .filter(Files::isRegularFile)
                            .filter(e -> {
                                // Find all signing metadata files.
                                String s = e.getFileName().toString();
                                return s.endsWith(".SF") || s.endsWith(".DSA") || s.endsWith(".RSA") || s.endsWith(".EC");
                            })
                            .forEach(sneak(Files::delete));

                    try (OutputStream os = Files.newOutputStream(manifestFile, StandardOpenOption.TRUNCATE_EXISTING)) {
                        manifest.write(os);
                        os.flush();
                    }
                }
                Files.copy(uniPair.getRight(), makeParents(newUniversalJar));
            } else {

                //TODO, grab license files from src jar.
                Files.copy(repoUniversalJar, makeParents(newUniversalJar));
            }

            Version.Library forgeLib = install.getLibraries().get(0);
            Version.Downloads downloads = new Version.Downloads();
            Version.LibraryDownload artifact = new Version.LibraryDownload();

            artifact.path = baseNotation.toPath();
            artifact.url = "";
            artifact.sha1 = HashUtils.hash(SHA1, newUniversalJar).toString();
            artifact.size = Math.toIntExact(Files.size(newUniversalJar));

            downloads.artifact = artifact;
            forgeLib.name = baseNotation;
            forgeLib.downloads = downloads;

            Files.write(newJarRoot.resolve("install_profile.json"), Utils.GSON.toJson(install).getBytes(StandardCharsets.UTF_8));
            Files.write(newJarRoot.resolve("version.json"), Utils.GSON.toJson(version).getBytes(StandardCharsets.UTF_8));
        }
    }

    public static Install generateInstallProfile(ProcessorContext ctx, Path newFilePath) throws IOException {
        Install install = new Install();
        install._comment_ = comment;
        install.spec = 0;
        install.profile = "forge";

        MavenNotation baseNotation = ctx.notation.withClassifier(null).withExtension("jar");

        String[] vSplit = baseNotation.version.split("-", 2);
        install.version = vSplit[0] + "-" + baseNotation.module + "-" + vSplit[1];
        install.icon = InstallerRewriter.ICON;
        install.json = "/version.json";
        install.path = baseNotation;
        install.logo = "/big_logo.png";
        install.minecraft = vSplit[0].replace("_", "-");//Replace _ with  - for prerelease versions
        install.welcome = "Welcome to the simple Forge installer.";
        install.mirrorList = MIRROR_LIST;

        List<Version.Library> libraries = install.getLibraries();
        Version.Library forgeLib = new Version.Library();
        libraries.add(forgeLib);//Add blank library, used by generateVersionInfo && rewriteLibrary. This is filled in after universal jar rewriting.

        return install;
    }

    public static Version generateVersionJson(boolean requiresLJF, Install newProfile, V1InstallProfile v1Profile, List<ClasspathEntry> classpathLibraries) throws IOException {
        V1InstallProfile.VersionInfo v1VersionInfo = v1Profile.versionInfo;
        Version version = new Version();
        version._comment_ = comment;
        version.id = newProfile.version;
        version.time = v1VersionInfo.time;
        version.releaseTime = v1VersionInfo.releaseTime;
        version.type = v1VersionInfo.type;
        version.mainClass = v1VersionInfo.mainClass;
        version.minecraftArguments = v1VersionInfo.minecraftArguments;
        v1VersionInfo.libraries.forEach(v -> {
            MavenNotation replacement = REPLACEMENTS.get(v.name);
            if (replacement != null) {
                LOGGER.info("Replacing {} with {}", v.name, replacement);
                v.name = replacement;
            }
            replacement = PER_VERSION_TABLE.get(newProfile.minecraft, v.name);
            if (replacement != null) {
                LOGGER.info("Replacing {} with {}", v.name, replacement);
                v.name = replacement;
            }
        });
        if (v1VersionInfo.inheritsFrom == null) {
            Path versionManifest = CACHE_DIR.resolve("version_manifest.json");
            downloadFile(VERSION_MANIFEST, versionManifest, true);

            Manifest manifest;
            try (BufferedReader reader = Files.newBufferedReader(versionManifest)) {
                manifest = Utils.GSON.fromJson(reader, Manifest.class);
            }

            String mcVersion = newProfile.minecraft;
            Path versionJson = CACHE_DIR.resolve(mcVersion + ".json");
            downloadFile(new URL(manifest.getUrl(mcVersion)), versionJson, true);

            Version mcVersionJson;
            try (BufferedReader reader = Files.newBufferedReader(versionJson)) {
                mcVersionJson = Utils.GSON.fromJson(reader, Version.class);
            }
            Set<MavenNotation> mcLibraries = mcVersionJson.getLibraries().stream()
                    .map(e -> e.name)
                    .collect(Collectors.toSet());
            v1VersionInfo.libraries.removeIf(e -> {
                // If our parent has the library, _and_ the v1 installer marked both client and server req as non existent, remove it.
                //  Special case JOptSimple as a few 1.7.2 versions use this on the client, but not on the server.
                if (mcLibraries.contains(e.name)
                        && e.clientreq == null
                        && e.serverreq == null
                        && !e.name.toString().startsWith("net.sf.jopt-simple:jopt-simple:")) {
                    LOGGER.debug("Removing {} from forge version json.", e.name);
                    return true;
                }

                // Try slower match against MC libraries, there are a few cases where either Mojang has updated libraries (authlib)
                //  or Forge has bumped them (guava/lang3).
                for (MavenNotation mcLib : mcLibraries) {
                    if (mcLib.group.equals(e.name.group) && mcLib.module.equals(e.name.module) && Objects.equals(mcLib.classifier, e.name.classifier)) {
                        if (mcLib.version.equals(e.name.version)) break; // It is pointless checking as it will always return false.

                        ComparableVersion mcV = new ComparableVersion(mcLib.version);
                        ComparableVersion forgeV = new ComparableVersion(e.name.version);
                        boolean remove = mcV.compareTo(forgeV) > 0;
                        if (remove) {
                            LOGGER.debug("Removing {} from forge version json. Minecraft manifest has newer version: {}", e.name, mcLib);
                        }
                        return remove;
                    }
                }

                //Forge has never shipped any versions with this on our own libraries.
                if (e.rules != null) throw new RuntimeException("Expected non-minecraft library to have no rules! " + e.name);
                if (e.natives != null) throw new RuntimeException("Expected non-minecraft library to have no natives! " + e.name);
                if (e.extract != null) throw new RuntimeException("Expected non-minecraft library to have no extract! " + e.name);
                return false;
            });
            version.inheritsFrom = mcVersion;
        } else {
            version.inheritsFrom = v1VersionInfo.inheritsFrom;
        }

        // If we require LegacyJavaFixer, inject it here.
        if (requiresLJF) {
            applyLJFVersion(version, v1VersionInfo, classpathLibraries);
        }

        List<Version.Library> libraries = version.getLibraries();
        for (V1InstallProfile.Library library : v1VersionInfo.libraries) {
            LOGGER.debug("Processing library: {}", library.name);
            Version.Library lib = rewriteLibrary(library, newProfile);
            libraries.add(lib);

            // The Forge universal jar's details are filled in later, ignore this.
            if (lib.name == null) continue;

            // Validate that the library exists on the Class-Path attribute.
            //  If it does not, add it, or if the version is incorrect (we may have force updated it), update it.
            int lastLib = 0;
            boolean found = false;
            for (int i = 0; i < classpathLibraries.size(); i++) {
                ClasspathEntry entry = classpathLibraries.get(i);
                if (!(entry instanceof LibraryClasspathEntry)) continue;
                lastLib = i;
                LibraryClasspathEntry l = (LibraryClasspathEntry) entry;
                if (lib.name.equals(l.notation)) {
                    LOGGER.debug("Classpath library {} validated.", l.notation);
                    found = true;
                    break;
                } else if (lib.name.group.equals(l.notation.group) && lib.name.module.equals(l.notation.module) && Objects.equals(lib.name.classifier, l.notation.classifier)) {
                    //Update the classpath if we have a newer version than a supplied library.
                    LOGGER.warn("Correcting incorrect library, Classpath assumes '{}', got '{}'", l.notation, lib.name);
                    l.modified = true;
                    found = true;
                    l.notation = lib.name;
                    break;
                }
            }
            if (found) continue;
            LOGGER.warn("Classpath library {}, not found! Adding entry.", lib.name);
            LibraryClasspathEntry entry = new LibraryClasspathEntry(lib.name);
            entry.modified = true;

            // Add the new entry after the last Library entry as we want to declare these before the Minecraft server jar.
            classpathLibraries.add(lastLib, entry);
        }

        // Validate all libraries declared in the Class-Path manifest entry exist.
        for (ClasspathEntry lE : classpathLibraries) {
            // Update the minecraft_server.jar entry to the new format.
            if (lE instanceof StringClasspathEntry) {
                StringClasspathEntry entry = (StringClasspathEntry) lE;
                String expectedPath = "minecraft_server." + newProfile.minecraft + ".jar";
                // Update old minecraft_server.jar references.
                if (entry.path.startsWith("minecraft_server") && !entry.path.equals(expectedPath)) {
                    entry.path = expectedPath;
                    entry.modified = true;
                }
                continue;
            }

            // Second pass at validating LibraryClasspathEntries. We simply check if the exact library exists in the manifest.
            //  This validates that anything previously declared on the classpath exists as a library in the manifest.
            if (!(lE instanceof LibraryClasspathEntry)) continue;
            LibraryClasspathEntry l = (LibraryClasspathEntry) lE;
            boolean found = false;
            for (Version.Library library : version.getLibraries()) {
                MavenNotation name = library.name;
                if (name == null) continue;

                if (name.equals(l.notation)) {
                    found = true;
                    break;
                }
            }
            if (found) continue;
            LOGGER.error("Classpath library {}, not found!", l.notation);
        }

        return version;
    }

    public static Version.Library rewriteLibrary(V1InstallProfile.Library oldLibrary, Install newProfile) throws IOException {

        MavenNotation name = oldLibrary.name;
        //This is the universal jar, without classifier.
        if (name.module.equals("forge") || name.module.equals("minecraftforge")) {
            return newProfile.getLibraries().get(0);
        }

        Version.Library library = new Version.Library();
        Version.Downloads downloads = new Version.Downloads();
        Version.LibraryDownload libraryDownload = new Version.LibraryDownload();
        libraryDownload.path = name.toPath();

        String repo = determineRepo(oldLibrary);
        LOGGER.debug("Using {} repository for library {}", repo, name);
        Path libraryPath = name.toPath(CACHE_DIR);
        URL url = name.toURL(repo);
        downloadFile(url, libraryPath);
        libraryDownload.url = url.toString();

        HashCode hash = HashUtils.hash(SHA1, libraryPath);
        if (oldLibrary.checksums != null && !oldLibrary.checksums.isEmpty()) {
            boolean matches = false;
            for (String checksum : oldLibrary.checksums) {
                if (HashUtils.equals(hash, checksum)) {
                    matches = true;
                    break;
                }
            }
            if (!matches) {
                String expected = "[" + String.join(", ", oldLibrary.checksums) + "]";
                //Suppress warnings about scala hashes changing, these were intentionally shrunk
                if (!name.group.startsWith("org.scala-lang")) {
                    LOGGER.warn("Old installer profile checksums could not be validated for {}. Got {}, Expected one of {}.", name, hash, expected);
                }
            }
        }
        libraryDownload.sha1 = hash.toString();
        libraryDownload.size = Math.toIntExact(Files.size(libraryPath));

        downloads.artifact = libraryDownload;
        library.name = name;
        library.downloads = downloads;
        return library;
    }

    public static boolean requiresLJF(MavenNotation name) {
        return LJF_REQUIRED_VERSIONS.contains(name.version);
    }

    public static void applyLJFManifest(java.util.jar.Manifest manifest) {
        Attributes mainAttribs = manifest.getMainAttributes();
        // Set the server-side Main-Class attribute for the universal jar when LJF is required.
        mainAttribs.put(new Attributes.Name("Main-Class"), SERVER_MAIN);
    }

    public static void applyLJFVersion(Version version, V1InstallProfile.VersionInfo v1VersionInfo, List<ClasspathEntry> classpathLibraries) {
        version.mainClass = CLIENT_MAIN;

        // Find the last Library entry to append after.
        int lastLibraryEntry = Math.max(0, classpathLibraries.size() - 1);
        for (int i = 0; i < classpathLibraries.size(); i++) {
            if (classpathLibraries.get(i) instanceof ClasspathEntry.LibraryClasspathEntry) continue;
            lastLibraryEntry = i;
            break;
        }

        LOGGER.debug("Adding extra library: {}", LJF);
        // Add LJF to installer profile, this will be processed later by the rest of V1Processor.
        V1InstallProfile.Library lib = new V1InstallProfile.Library();
        lib.name = LJF;
        v1VersionInfo.libraries.add(lib);

        // Append a Classpath entry to the universal jar.
        ClasspathEntry.LibraryClasspathEntry ent = new ClasspathEntry.LibraryClasspathEntry(LJF);
        ent.modified = true;
        classpathLibraries.add(lastLibraryEntry, ent);
    }

    // Determine the repository to use for the library, if mojang has it, prefer that.
    public static String determineRepo(V1InstallProfile.Library library) throws IOException {
        // If we are forcing the use of local files.
        if (USE_LOCAL_CACHE) {
            LOGGER.debug("Forcing use of local cache for {}", library.name);
            // First try to grab files from ~/.m2/repository/
            if (headRequest(library.name.toURL(MAVEN_LOCAL))) {
                return MAVEN_LOCAL;
            }
            // Otherwise try from our existing cache dir.
            String cacheDir = CACHE_DIR.toUri().toString();
            if (headRequest(library.name.toURL(cacheDir))) {
                return cacheDir;
            }

            // If we don't have it, Download it and use the cache dir.
            String maven = findFirstMaven(library, MAVENS);
            downloadFile(library.name.toURL(maven), library.name.toPath(CACHE_DIR));
            return cacheDir;
        }

        return findFirstMaven(library, MAVENS);
    }

    // Try and find a maven repository that has the given library.
    public static String findFirstMaven(V1InstallProfile.Library library, String[] mavens) throws IOException {
        for (String maven : mavens) {
            if (headRequest(library.name.toURL(maven))) {
                return maven;
            }
        }
        String s = Arrays.stream(mavens).collect(Collectors.joining("\n\t", "\t", "\n\n"));
        throw new IllegalStateException("Could not find a repository for '" + library.name + "'. Searched: \n" + s);
    }
}
